<!--
    - Policies are applied in the order they appear.
    - Position <base/> inside a section to inherit policies from the outer scope.
    - Comments within policies are not preserved.
-->
<!-- Add policies as children to the <inbound>, <outbound>, <backend>, and <on-error> elements -->
<policies>
	<!-- Throttle, authorize, validate, cache, or transform the requests -->
    <!-- Policy Date: 10/10/2025 -->
	<inbound>
		<base />
		<cache-lookup-value key="@("listBackends-" + context.Api.Id)" variable-name="listBackends" />
        <!-- set the request ID in case we need to debug with OpenAI Service -->
        <set-header name="x-ms-client-request-id" exists-action="override">
			<value>@(context.Request.Headers.GetValueOrDefault("x-S7P-id", Guid.NewGuid().ToString()))</value>
		</set-header>
		<choose>
			<when condition="@(context.Variables.ContainsKey("listBackends") == false)">
				<set-variable name="listBackends" value="@{
                    JArray backends = new JArray();
                    string salt = "0123456789"; // 10-digit salt
                    
                    //backends.Add(new JObject()
                   // {
                    //    { "url", "https://nvmopenai3.openai.azure.com/" },
                    //    { "priority", 1},
                    //    { "affinity", "" }, // Will be calculated afterwards
                    //    { "isThrottling", false },
                    //    { "retryAfter", DateTime.MinValue } ,
                    //    { "ModelType", "PTU" },
                    //    { "acceptablePriorities", new JArray(1,2,3) },
                    //    { "LimitConcurrency", "off"},
                    //    { "api-key", ""},
                    //    { "defaultRetryAfter", 10 } // Default retry-after value in seconds
                    //});
                    backends.Add(new JObject()
                    {
                        { "url", "https://nvm2.openai.azure.com/" },
                        { "priority", 2},
                        { "affinity", "" }, // Will be calculated afterwards
                        { "isThrottling", false },
                        { "retryAfter", DateTime.MinValue } ,
                        { "ModelType", "PAYGO" },
                        { "acceptablePriorities", new JArray(1,2) },
                        { "LimitConcurrency", "off"},
                        { "api-key", ""},
                        { "defaultRetryAfter", 10 } // Default retry-after value in seconds
                    });

                    foreach (JObject backend in backends) {
                        string saltedUrl = salt + backend["url"].ToString();
                        backend["affinity"] = string.Concat(
                            System.Security.Cryptography.SHA256.Create()
                            .ComputeHash(System.Text.Encoding.UTF8.GetBytes(saltedUrl))
                            .Take(10)
                            .Select(b => b.ToString("x2"))
                        );
                    }
        
                    return backends;  
                    }" />
				<!-- And store the variable into cache again -->
				<cache-store-value key="@("listBackends-" + context.Api.Id)" value="@((JArray)context.Variables["listBackends"])" duration="60" />
			</when>
		</choose>
		<set-variable name="priorityCfg" value="@{
            // Create a JObject for priority configuration
            JObject cfg = new JObject();
            cfg["1"] = new JObject {
                { "retryCount", 12 },
                { "requeue", true }
            };
            cfg["2"] = new JObject {
                { "retryCount", 9 },
                { "requeue", false }
            };
            cfg["3"] = new JObject {
                { "retryCount", 1 },
                { "requeue", true }
            };
            return cfg;
        }" />
		<!--  set the priority to 3 if not set -->
		<set-variable name="RequestPriority" value="@{
            const int defaultPriority = 3;
            return context.Request.Headers.TryGetValue("llm_proxy_priority", out var priorityValues) &&
                int.TryParse(priorityValues.FirstOrDefault(), out int parsedPriority)
                ? parsedPriority
                : defaultPriority;
        }" />
        <set-variable name="RequestAffinityBackendIdx" value="@{
            string affinityHeader = context.Request.Headers.GetValueOrDefault("x-backend-affinity", "");
                    
            // Find the backend with the matching affinity
            if (!string.IsNullOrEmpty(affinityHeader)) {
                JArray backends = (JArray)context.Variables["listBackends"];
                for (int i = 0; i < backends.Count; i++) {
                    JObject backend = (JObject)backends[i];
                    if (string.Equals(backend["affinity"]?.ToString(), affinityHeader, StringComparison.OrdinalIgnoreCase)) {
                        return i;  // Return the index of the matching backend
                    }
                }
            }
            
            // Return -1 if no affinity header or no match found
            return -1;
        }" />
        <!-- Get the list of backend indexes that can handle the requested priority -->
		<set-variable name="PriBackendIndxs" value="@{
            JArray list =  new JArray();
            JArray backends = (JArray)context.Variables["listBackends"];
            int requestPriority = (int)context.Variables["RequestPriority"];
            for (int i = 0; i < backends.Count; i++) {
                JObject backend = (JObject)backends[i];
                if (backend["acceptablePriorities"]?.Values<int>().Contains(requestPriority) == true) {
                    list.Add(i);
                }
            }
            return list;
        }" />
		<set-variable name="RetryCount" value="@{
            return ((JObject)context.Variables["priorityCfg"])
                .GetValue(context.Variables.GetValueOrDefault<int>("RequestPriority", 3).ToString())?
                .Value<int>("retryCount") ?? 1;
        }" />
		<set-variable name="ShouldRequeue" value="@{
            return ((JObject)context.Variables["priorityCfg"])
                .GetValue(context.Variables.GetValueOrDefault<int>("RequestPriority", 3).ToString())?
                .Value<bool>("requeue") ?? true;
        }" />
		<authentication-managed-identity resource="https://cognitiveservices.azure.com" output-token-variable-name="managed-id-access-token" ignore-error="false" />
        <set-variable name="backendCallCounter" value="@(0)" />
        <set-variable name="PolicyCycleCounter" value="@{
            return context.Request.Headers.TryGetValue("x-PolicyCycleCounter", out var priorityValues) &&
                int.TryParse(priorityValues.FirstOrDefault(), out int parsedCounter)   ? parsedCounter : 0;   // return 0 if not set
        }" />
	</inbound>
	<!-- Control if and how the requests are forwarded to services  -->
	<backend>
        <retry condition="@(context.Variables.GetValueOrDefault<bool>("ShouldRetry", true))" count="@(context.Variables.GetValueOrDefault<int>("RetryCount", 20) )" interval="1" delta="1">

			<!-- Before picking the backend, let's verify if there is any that should be set to not throttling anymore -->
			<set-variable name="listBackends" value="@{
                JArray backends = (JArray)context.Variables["listBackends"];

                backends.OfType<JObject>()
                    .Where(backend => backend.Value<bool>("isThrottling") && DateTime.UtcNow >= backend.Value<DateTime>("retryAfter"))
                    .ToList()
                    .ForEach(backend => {
                        backend["isThrottling"] = false;
                        backend["retryAfter"] = DateTime.MinValue;
                    });


                // check if the previous run was limited or timed out.  Mark backend for throttling if so.
                var callCompleted = context.Variables.GetValueOrDefault<bool>("callCompleted", true);
                var lastStatusCode = context.Response?.StatusCode ?? 0;
                var shouldLimit = context.Variables.GetValueOrDefault<string>("shouldLimit", "off");
                var wasLimited = context.Variables.GetValueOrDefault<bool>("wasLimited", false);
                var backendIndex = context.Variables.GetValueOrDefault<int>("backendIndex", -1);

                // There was either a timeout  or a limitConcurrency that was hit
                if ( (!callCompleted && lastStatusCode!=200) || (shouldLimit!="off" && wasLimited && backendIndex >= 0 && backendIndex < backends.Count) ) {
                    JObject backend = (JObject)backends[backendIndex];
                    backend["isThrottling"] = true;
                    backend["retryAfter"] = DateTime.UtcNow.AddSeconds(4);
                }

                return backends;
            }" />
			<cache-store-value key="@("listBackends-" + context.Api.Id)" value="@((JArray)context.Variables["listBackends"])" duration="60" />

            <choose>
                <when condition="@( context.Variables.GetValueOrDefault<int>("backendCallCounter", 0)==0)">
                    <set-variable name="backendLog" value="@{
                        int requestPriority = (int)context.Variables["RequestPriority"];
                        JArray priorityBackendIndxs = (JArray)context.Variables["PriBackendIndxs"];
                        JArray backends = context.Variables.GetValueOrDefault<JArray>("listBackends", new JArray());
                        var retryCount = context.Variables.GetValueOrDefault<int>("RetryCount", -1);

                        string backendLog = "BACKENDS: ";

                        foreach (int i in priorityBackendIndxs) {
                            JObject backend = (JObject)backends[i];
                            backendLog += "  index=" + i + " RetryCount: " + retryCount + "  isThrottling=" + backend.Value<bool>("isThrottling") +
                            " retryAfter=" + backend.Value<DateTime>("retryAfter").ToString("yyyy-MM-ddTHH:mm:ssZ");
                        }

                        //backendLog += " REQUEST PRIORITY: " + requestPriority +
                        //        "  REQUEST-HEADERS: " +   string.Join(", ",
                        //        context.Request.Headers
                        //            .Where(h => !string.Equals(h.Key, "api-key", StringComparison.OrdinalIgnoreCase) &&
                        //                        !string.Equals(h.Key, "Authorization", StringComparison.OrdinalIgnoreCase))
                        //            .Select(h => $"{h.Key}: {string.Join(", ", h.Value)}")
                        //    );
                        return backendLog;

                    }" />
                </when>
            </choose>

			<!-- This is the main logic to pick the backend to be used -->
			<set-variable name="backendIndex" value="@{
                // Retrieve the list of backends
                JArray backends = context.Variables.GetValueOrDefault<JArray>("listBackends", new JArray());
                if (!backends.Any()) {return -1;}

                JArray priorityBackendIndxs = (JArray)context.Variables["PriBackendIndxs"];
                int backendCallCount = context.Variables.GetValueOrDefault<int>("backendCallCounter", 0);
                
                // Only check backend affinity on the first call
                if (backendCallCount == 0) {
                    int affinityBackendIdx = context.Variables.GetValueOrDefault<int>("RequestAffinityBackendIdx", -1);

                    // Check if we have a valid affinity backend and it's in our priority list
                    if (affinityBackendIdx != -1 ) {
                        JObject backend = (JObject)backends[affinityBackendIdx];
                        // Only use the affinity backend if it's not throttling
                        if (!backend.Value<bool>("isThrottling")) {
                            return affinityBackendIdx;
                        }
                    }
                }

                // If no affinity match found or not the first call, proceed with normal selection
                // Find all non-throttling backends that support the request priority
                var availableBackends = new List<int>();
                int lowestPriority = int.MaxValue;
                
                // Find the lowest priority available backends
                foreach (int i in priorityBackendIndxs) {
                    JObject backend = (JObject)backends[i];
                    if (!backend.Value<bool>("isThrottling")) {
                        int priority = backend.Value<int>("priority");
                        if (priority < lowestPriority) {
                            lowestPriority = priority;
                            availableBackends.Clear();
                            availableBackends.Add(i);  // Store the index instead of the backend object
                        } else if (priority == lowestPriority) {
                            availableBackends.Add(i);  // Store the index instead of the backend object
                        }
                    }
                }

                if (!availableBackends.Any())  { return -1; }

                // pick a random backend from the available ones
                return availableBackends[ new Random(context.RequestId.GetHashCode()).Next(availableBackends.Count) ];

            }" />
            <set-variable name="shouldLimit" value="@{
                // Check if the backend should limit concurrency
                JArray backends = context.Variables.GetValueOrDefault<JArray>("listBackends", new JArray());
                int backendIndex = (int)context.Variables["backendIndex"];
                if (backendIndex < 0 || backendIndex >= backends.Count) { return "off"; }
                JObject backend = (JObject)backends[backendIndex];
                return backend.Value<string>("LimitConcurrency");
            }" />
			<!-- Make the request to the selected backend -->
			<set-variable name="RetryCount" value="@(context.Variables.GetValueOrDefault<int>("RetryCount") - 1)" />
            <set-variable name="PolicyCycleCounter" value="@(context.Variables.GetValueOrDefault<int>("PolicyCycleCounter") + 1)" />
			<set-variable name="backendLog" value="@{
                int backendIndex = (int)context.Variables["backendIndex"];
                int RetryCount = (int)context.Variables["RetryCount"];
                int PolicyCycleCounter = (int)context.Variables["PolicyCycleCounter"];
                var shouldLimit = context.Variables.GetValueOrDefault<string>("shouldLimit", "off");

                string backendLog = context.Variables.GetValueOrDefault<string>("backendLog", "");
                backendLog += "  RETRIES: " + RetryCount + " POLICY CYCLE COUNTER: " + PolicyCycleCounter + 
                              "  NEXT INDEX TO TRY: " + backendIndex + " SHOULD LIMIT: " + shouldLimit + 
                              "  NOW=" + DateTime.UtcNow.ToString("yyyy-MM-ddTHH:mm:ssZ");
                return backendLog;
            }" />
			<choose>
				<when condition="@(context.Variables.GetValueOrDefault<int>("backendIndex", 0) > -1 && context.Variables.GetValueOrDefault<int>("RetryCount") >= 0)">
					<!-- Set each backend configuration value individually -->
					<set-variable name="selectedBackend" value="@(((JArray)context.Variables["listBackends"])[(int)context.Variables["backendIndex"]])" />
					<set-variable name="backendUrl" value="@(((JObject)context.Variables["selectedBackend"]).Value<string>("url") + "/openai")" />
					<set-variable name="ModelType" value="@(((JObject)context.Variables["selectedBackend"]).Value<string>("ModelType"))" />
					<set-variable name="api-key" value="@(((JObject)context.Variables["selectedBackend"]).Value<string>("api-key"))" />
					<set-variable name="backendCallCounter" value="@(context.Variables.GetValueOrDefault<int>("backendCallCounter") + 1)" />
					<!-- Set the backend service URL -->
					<set-backend-service base-url="@((string)context.Variables["backendUrl"])" />
					<!-- use Managed Identity or the API-Key -->
					<choose>
						<when condition="@(context.Variables.GetValueOrDefault<string>("api-key", "") != "")">
							<set-header name="api-key" exists-action="override">
								<value>@((string)context.Variables["api-key"])</value>
							</set-header>
						</when>
						<otherwise>
							<set-header name="Authorization" exists-action="override">
								<value>@("Bearer " + (string)context.Variables["managed-id-access-token"])</value>
							</set-header>
						</otherwise>
					</choose>
					<set-variable name="backendLog" value="@{
                        string backendLog = context.Variables.GetValueOrDefault<string>("backendLog", "");
                        int index         = context.Variables.GetValueOrDefault<int>("backendIndex", 0);

                        backendLog += "  Using " + ((JObject)((JArray)context.Variables["listBackends"])[index]).Value<string>("ModelType") + " backend: Now=";
                        backendLog += DateTime.UtcNow.ToString("yyyy-MM-ddTHH:mm:ssZ") + " - " + ((JObject)((JArray)context.Variables["listBackends"])[index]).Value<string>("url"); 

                        return backendLog;
                    }" />
                    <!-- If the endpoint is concurrency limited, it will immedietly retry -->

                    <set-variable name="callCompleted" value="@(false)" />
                    <set-variable name="wasLimited" value="@(true)" />
                    <choose>
                        <when condition="@(context.Variables.GetValueOrDefault<string>("shouldLimit", "off") == "low")">
                            <limit-concurrency key="PTU" max-count="10">
                                <forward-request buffer-request-body="true" buffer-response="false" timeout="300"/>
                            </limit-concurrency>
                        </when>
                        <when condition="@(context.Variables.GetValueOrDefault<string>("shouldLimit", "off") == "medium")">
                            <limit-concurrency key="PTU" max-count="50">
                                <forward-request buffer-request-body="true" buffer-response="false" timeout="300" />
                            </limit-concurrency>
                        </when>
                        <when condition="@(context.Variables.GetValueOrDefault<string>("shouldLimit", "off") == "high")">
                            <limit-concurrency key="PTU" max-count="100">
                                <forward-request buffer-request-body="true" buffer-response="false" timeout="300" />
                            </limit-concurrency>
                        </when>
                        <otherwise>
                            <set-variable name="wasLimited" value="@(false)" />
        					<forward-request buffer-request-body="true" buffer-response="false" timeout="300"/>
                        </otherwise>
                    </choose>
                    <set-variable name="wasLimited" value="@(false)" />
                    <set-variable name="callCompleted" value="@(true)" />

					<set-variable name="backendLog" value="@{
                        string backendLog = context.Variables.GetValueOrDefault<string>("backendLog", "");
                        //backendLog += "  HEADERS: Now=" + DateTime.UtcNow.ToString("yyyy-MM-ddTHH:mm:ssZ") +
                        //    " - " + string.Join(", ", context.Response.Headers.Select(h => $"{h.Key}: {string.Join(", ", h.Value)}"));
                        return backendLog;
                    }" />
				</when>
			</choose>

			<!-- Temporary Errors:  408, 429 and 50xx  -->
            <set-variable name="isTempError" value="@{
                // A timeout causes context.Response to be null
                bool isTimeout = context.Response == null;
                
                // For other errors, check status codes
                bool isErrorStatus = context.Response != null && 
                    (context.Response.StatusCode == 429 || 
                    context.Response.StatusCode == 408 || 
                    context.Response.StatusCode >= 500);
                
                // If we have a timeout, also log it
                if (isTimeout) {
                    var startTime = context.Variables.GetValueOrDefault<DateTime>("requestStartTime", DateTime.MinValue);
                    var duration = DateTime.UtcNow - startTime;
                }
                
                return isTimeout || isErrorStatus;
            }" />
            <!-- Permanent Errors:  >400 , !408, !429 , <500   -->
            <set-variable name="isPermError" value="@(
                context.Response != null && 
                (context.Response.StatusCode >= 400 && context.Response.StatusCode < 500 &&
                context.Response.StatusCode != 408 && context.Response.StatusCode != 429 )
            )" />

            <set-variable name="backendLog" value="@{
                        string backendLog = context.Variables.GetValueOrDefault<string>("backendLog", "");
                        backendLog += "  isPermError:  " + context.Variables.GetValueOrDefault<bool>("isPermError", false) +
                         "  isTempError: " + context.Variables.GetValueOrDefault<bool>("isTempError", false) + 
                         "  Context.Response.StatusCode: " + context.Response?.StatusCode ?? "N/A";
                            
                        return backendLog;
                }" />
			<choose>
				<when condition="@(context.Variables.GetValueOrDefault<bool>("isTempError", true) )">
					<cache-lookup-value key="@("listBackends-" + context.Api.Id)" variable-name="listBackends" />
					<set-variable name="listBackends" value="@{
                        JArray backends = (JArray)context.Variables["listBackends"];
                        int currentBackendIndex = (int)context.Variables["backendIndex"];

                        // Validate backend index
                        if (currentBackendIndex < 0 || currentBackendIndex >= backends.Count) {
                            return backends; // Return unchanged if index is invalid
                        }

                        JObject backend = (JObject)backends[currentBackendIndex];

                        // Attempt to retrieve retry-after duration from headers
                        string[] retryHeaders = new[] { "retry-after" };
                        int retryAfterSeconds = backend["defaultRetryAfter"].Value<int>(); 

                        foreach (string headerName in retryHeaders) {

                            if (context.Response.Headers.Keys.Any(k => string.Equals(k, headerName, StringComparison.OrdinalIgnoreCase))){
                                string headerValue = context.Response.Headers[headerName].FirstOrDefault();

                                if (int.TryParse(headerValue, out int parsedValue) && parsedValue > 0)
                                {
                                    retryAfterSeconds = parsedValue + 2;
                                    break;
                                }
                            }
                        }

                        // Update backend status
                        backend["isThrottling"] = true;

                        // we're multi-processing, so we need to set the retryAfter to the max of the current and the new one
                        var newRetryAfter = DateTime.UtcNow.AddSeconds(retryAfterSeconds);
                        if (newRetryAfter > backend["retryAfter"].Value<DateTime>()) {
                            backend["retryAfter"] = newRetryAfter;
                        }

                        return backends;     
                    }" />
					<cache-store-value key="@("listBackends-" + context.Api.Id)" value="@((JArray)context.Variables["listBackends"])" duration="60" />
				</when>
			</choose>
			<set-variable name="unThrottledBackends" value="@{
                var backends = context.Variables.GetValueOrDefault<JArray>("listBackends", new JArray());
                var priorityBackendIndxs = (JArray)context.Variables["PriBackendIndxs"];
                int count=0;
                foreach (int i in priorityBackendIndxs) {
                    JObject backend = (JObject)backends[i];
                    if (!backend.Value<bool>("isThrottling")) {
                        count++;
                    }
                }
                return count;
            }" />
			<set-variable name="ShouldRetry" value="@{
                var isPermError = context.Variables.GetValueOrDefault<bool>("isPermError", false);
                var retryCount = context.Variables.GetValueOrDefault<int>("RetryCount", -1);
                var unthrottled = context.Variables.GetValueOrDefault<int>("unThrottledBackends", 0);
                var ShouldRequeue = context.Variables.GetValueOrDefault<bool>("ShouldRequeue", true);
                var proxyRequeue = ShouldRequeue && (unthrottled == 0);

                return (!isPermError && retryCount >= 0) && !proxyRequeue;
            }" />

			<set-variable name="ShouldRequeueNow" value="@{
                var isPermError = context.Variables.GetValueOrDefault<bool>("isPermError", false);
                var ShouldRetry = context.Variables.GetValueOrDefault<bool>("ShouldRetry", true);
                var ShouldRequeue = context.Variables.GetValueOrDefault<bool>("ShouldRequeue", true);

                return !isPermError && ShouldRequeue && !ShouldRetry;
            }" />

            <set-variable name="backendLog" value="@{
                var ShouldRetry = context.Variables.GetValueOrDefault<bool>("ShouldRetry", true);
                var ShouldRequeueNow = context.Variables.GetValueOrDefault<bool>("ShouldRequeueNow", true);
                var isTempError = context.Variables.GetValueOrDefault<bool>("isTempError", true);
                var isPermError = context.Variables.GetValueOrDefault<bool>("isPermError", false);
                var retryCount = context.Variables.GetValueOrDefault<int>("RetryCount", -1);
                var count = context.Variables.GetValueOrDefault<int>("unThrottledBackends", 0);
 
                string backendLog = context.Variables.GetValueOrDefault<string>("backendLog", "");
                backendLog += "  SUMMARY:--  SHOULD RETRY: " + ShouldRetry + "  SHOULD REQUEUE: " + ShouldRequeueNow +
                     "  isTempError: " + isTempError + "  isPermError: " + isPermError + "  RetryCount: " + retryCount + "  UnthrottledBackends: " + count +
                              "  --:END   ";
                return backendLog;
            }" />
            <!-- Determine if next action is retry, requeue, or return response -->
			<choose>
				<!-- If we got a 200, skip the retry and return the response -->
				<when condition="@(context.Variables.GetValueOrDefault<bool>("callCompleted", false) && context.Response != null && context.Response.StatusCode == 200)">
					<choose>
                        <when condition="@(context.Response.Headers.ContainsKey("Transfer-Encoding") && context.Response.Headers["Transfer-Encoding"].Contains("chunked"))">
                            <!-- For streaming responses, success is indicated by 200 status -->
                            <set-variable name="ShouldRetry" value="@(false)" />
                        </when>
						<when condition="@( !context.Response.Headers.ContainsKey("Content-Length") || context.Response.Headers["Content-Length"].FirstOrDefault() == "0" || context.Response.Body is null )" >
							<set-variable name="ShouldRetry" value="@(true)" />
							<!-- <set-variable name="RetryCount" value="@(context.Variables.GetValueOrDefault<int>("RetryCount") + 1)" /> -->
							<set-variable name="ShouldRequeue" value="@(false)" />
						</when>
						<otherwise>
							<set-variable name="ShouldRetry" value="@(false)" />
						</otherwise>
					</choose>
				</when>

                <!-- If all backends are throttling, calculate sleep time and return a 429 -->
				<when condition="@(context.Variables.GetValueOrDefault<bool>("ShouldRequeueNow", true))">
					<set-variable name="ShouldRetry" value="@(false)" />
					<set-variable name="sleepDuration" value="@{

                        JArray backends = context.Variables.GetValueOrDefault<JArray>("listBackends", new JArray());
                        JArray priorityBackendIndxs = (JArray)context.Variables["PriBackendIndxs"];
                        DateTime minRetryTime  = DateTime.MaxValue;

                        foreach (int i in priorityBackendIndxs) {
                            if (backends[i].Value<bool>("isThrottling") && backends[i].Value<DateTime>("retryAfter") < minRetryTime) {
                                minRetryTime = backends[i].Value<DateTime>("retryAfter");
                            }
                        }

                        if (minRetryTime > DateTime.UtcNow)  {
                            return (int)Math.Min(120000,  (minRetryTime - DateTime.UtcNow).TotalMilliseconds);
                        }

                        return 1000;
                    }" />
					<!-- <set-variable name="backendLog" value="@{
                        string backendLog = context.Variables.GetValueOrDefault<string>("backendLog", "");
                        backendLog += "  No available backends: Now=" + DateTime.UtcNow.ToString("yyyy-MM-ddTHH:mm:ssZ") + " Sleep=" + ((int)context.Variables["sleepDuration"]).ToString() + "ms";
                        return backendLog;
                    }" />
					<send-request mode="new" response-variable-name="sleepResponse" timeout="@(Math.Min(10, (int)Math.Ceiling(((double)context.Variables["sleepDuration"])/1000) + 1))">
						<set-url>@("https://your-backend-service/sleep?milliseconds=" + context.Variables["sleepDuration"])</set-url>
						<set-method>GET</set-method>
					</send-request>
                    -->
					<return-response>
						<set-status code="429" reason="Requeue Message" />
						<set-header name="S7PREQUEUE" exists-action="override">
							<value>true</value>
						</set-header>
						<set-header name="retry-after-ms" exists-action="override">
							<value>@(context.Variables.GetValueOrDefault<int>("sleepDuration",10000).ToString())</value>
						</set-header>
                        <set-header name="x-Backend-Attempts" exists-action="override">
                            <value>@(context.Variables.GetValueOrDefault<int>("backendCallCounter", 0).ToString())</value>
                        </set-header>
                        <set-header name="x-PolicyCycleCounter" exists-action="override">
                            <value>@(context.Variables.GetValueOrDefault<int>("PolicyCycleCounter", 0).ToString())</value>
                        </set-header>
                        <set-header name="backendLog" exists-action="override">
                            <value>@((string)context.Variables.GetValueOrDefault("backendLog", ""))</value>
                        </set-header>
					</return-response>
				</when>

                <!-- If we got a permanent error, return the error code -->
                <when condition="@(context.Variables.GetValueOrDefault<bool>("isPermError", true))">
                    <return-response>
                        <set-status code="@(context.Response?.StatusCode ?? 500)" reason="Permanent Error" />                        
                        <set-header name="x-Backend-Attempts" exists-action="override">
                            <value>@(context.Variables.GetValueOrDefault<int>("backendCallCounter", 0).ToString())</value>
                        </set-header>
                        <set-header name="x-PolicyCycleCounter" exists-action="override">
                            <value>@(context.Variables.GetValueOrDefault<int>("PolicyCycleCounter", 0).ToString())</value>
                        </set-header>
                        <set-header name="backendLog" exists-action="override">
                            <value>@((string)context.Variables.GetValueOrDefault("backendLog", ""))</value>
                        </set-header>
                    </return-response>
                </when>

                <!-- If we exhausted all retries, return a 412 -->
                <when condition="@(context.Variables.GetValueOrDefault<int>("RetryCount") < 0)">
                    <return-response>
                        <set-status code="412" reason="Retry Count Exhausted" />
                        <set-header name="x-Backend-Attempts" exists-action="override">
                            <value>@(context.Variables.GetValueOrDefault<int>("backendCallCounter", 0).ToString())</value>
                        </set-header>
                        <set-header name="x-PolicyCycleCounter" exists-action="override">
                            <value>@(context.Variables.GetValueOrDefault<int>("PolicyCycleCounter", 0).ToString())</value>
                        </set-header>
                        <set-header name="backendLog" exists-action="override">
                            <value>@((string)context.Variables.GetValueOrDefault("backendLog", ""))</value>
                        </set-header>
                    </return-response>
                </when>
                <otherwise>
                    <set-variable name="backendLog" value="@{
                        string backendLog = context.Variables.GetValueOrDefault<string>("backendLog", "");
                        backendLog += "  Retrying... Now=" + DateTime.UtcNow.ToString("yyyy-MM-ddTHH:mm:ssZ");
                        return backendLog;
                    }" />
                    <!-- Continue retrying -->
                </otherwise>
			</choose>
		</retry>
	</backend>
	<!-- Customize the responses -->
	<outbound>
		<base />
        <set-header name="TOKENPROCESSOR" exists-action="override">
            <value>MultiLineAllUsage</value>
        </set-header>
        <set-header name="x-backend-affinity" exists-action="override">
            <value>@(((JObject)context.Variables["selectedBackend"]).Value<string>("affinity"))</value>
        </set-header>
        <set-header name="x-Backend-Attempts" exists-action="override">
            <value>@(context.Variables.GetValueOrDefault<int>("backendCallCounter", 0).ToString())</value>
        </set-header>
        <set-header name="x-PolicyCycleCounter" exists-action="override">
            <value>@(context.Variables.GetValueOrDefault<int>("PolicyCycleCounter", 0).ToString())</value>
        </set-header>
        <set-header name="backendLog" exists-action="override">
            <value>@((string)context.Variables.GetValueOrDefault("backendLog", ""))</value>
        </set-header>
		<!-- <include-fragment fragment-id="LogResponseFragment" /> -->
	</outbound>
	<!-- Handle exceptions and customize error responses  -->
	<on-error>
		<set-header name="backendLog" exists-action="override">
			<value>@((string)context.Variables.GetValueOrDefault("backendLog", ""))</value>
		</set-header>
		<base />
	</on-error>
</policies>